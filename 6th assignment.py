# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kSDzYCHxAXVP1JwvEkzNb554Zb0jPd40
"""

#first solution
def reconstruct_permutation(s):
    n = len(s)
    perm = []
    low, high = 0, n

    for c in s:
        if c == 'I':
            perm.append(low)
            low += 1
        elif c == 'D':
            perm.append(high)
            high -= 1

    perm.append(low)  # or perm.append(high) since they have the same value at the end
    return perm

#second solution
def search_matrix(matrix, target):
    m = len(matrix)
    n = len(matrix[0])
    row = 0
    col = n - 1

    while row < m and col >= 0:
        mid_row = row + (m - row) // 2
        mid_col = col // 2

        if matrix[mid_row][mid_col] == target:
            return True
        elif matrix[mid_row][mid_col] > target:
            col = mid_col - 1
        else:
            row = mid_row + 1

    return False

#thrid solution
def valid_mountain_array(arr):
    n = len(arr)
    if n < 3:
        return False

    i = 1
    while i < n and arr[i] > arr[i-1]:
        i += 1

    if i == 1 or i == n:
        return False

    while i < n and arr[i] < arr[i-1]:
        i += 1

    return i == n

#forth solution
def find_max_length(nums):
    max_length = 0
    prefix_sums = {0: -1}
    cumulative_sum = 0

    for i, num in enumerate(nums):
        if num == 1:
            cumulative_sum += 1
        else:
            cumulative_sum -= 1

        if cumulative_sum in prefix_sums:
            max_length = max(max_length, i - prefix_sums[cumulative_sum])
        else:
            prefix_sums[cumulative_sum] = i

    return max_length

#fifth solution
def minimum_product_sum(nums1, nums2):
    nums1.sort()
    nums2.sort(reverse=True)

    min_product_sum = 0

    for i in range(len(nums1)):
        min_product_sum += nums1[i] * nums2[i]

    return min_product_sum

#sixth solution
from collections import defaultdict

def retrieve_original_array(changed):
    num_count = defaultdict(int)

    for num in changed:
        num_count[num] += 1

    for num in changed:
        if num_count[num] == 0:
            return []

        num_count[num] -= 1

        if num_count[2 * num] == 0:
            return []

        num_count[2 * num] -= 1

    original = []
    for num in set(changed):
        original.extend([num] * num_count[num])

    return original

#seventh solution
def generate_spiral_matrix(n):
    matrix = [[0] * n for _ in range(n)]
    num = 1
    top_row, bottom_row = 0, n - 1
    left_col, right_col = 0, n - 1

    while num <= n * n:
        # Traverse top row from left to right
        for i in range(left_col, right_col + 1):
            matrix[top_row][i] = num
            num += 1
        top_row += 1

        # Traverse right column from top to bottom
        for i in range(top_row, bottom_row + 1):
            matrix[i][right_col] = num
            num += 1
        right_col -= 1

        # Traverse bottom row from right to left
        for i in range(right_col, left_col - 1, -1):
            matrix[bottom_row][i] = num
            num += 1
        bottom_row -= 1

        # Traverse left column from bottom to top
        for i in range(bottom_row, top_row - 1, -1):
            matrix[i][left_col] = num
            num += 1
        left_col += 1

    return matrix

#eight solution
from typing import List

def multiply_sparse_matrices(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
    m, k = len(mat1), len(mat1[0])
    n = len(mat2[0])

    # Initialize the resulting matrix with zeros
    result = [[0] * n for _ in range(m)]

    # Create a transpose of mat2 for efficient column access
    mat2_transpose = list(zip(*mat2))

    # Perform matrix multiplication
    for i in range(m):
        for j in range(n):
            # Multiply non-zero elements of mat1 with corresponding elements in mat2_transpose
            for x, y in zip(mat1[i], mat2_transpose[j]):
                result[i][j] += x * y

    return result